<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <ResourcePreloader />
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]" />
    <link rel="stylesheet" href="@Assets["app.css"]" />
    <link rel="stylesheet" href="@Assets["AoC2025.styles.css"]" />
    <ImportMap />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet @rendermode="InteractiveServer" />
</head>

<body>
    <Routes @rendermode="InteractiveServer" />
    <ReconnectModal />
    <script src="@Assets["_framework/blazor.web.js"]"></script>

    <script>
        // Global canvas state to maintain consistent scaling
        window.canvasState = window.canvasState || {
            scale: null,
            minX: null,
            maxX: null,
            minY: null,
            maxY: null,
            padding: 20
        };

        window.resetCanvasScale = function() {
            window.canvasState.scale = null;
            window.canvasState.minX = null;
            window.canvasState.maxX = null;
            window.canvasState.minY = null;
            window.canvasState.maxY = null;
        };

        window.drawLines = function(lines, clearCanvas = true) {
            console.log('Drawing lines...');
            const canvas = document.getElementById('lineCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            if (clearCanvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                window.resetCanvasScale();
            }

            // Calculate bounds
            let minX = Math.min(...lines.map(l => Math.min(l.x1, l.x2)));
            let maxX = Math.max(...lines.map(l => Math.max(l.x1, l.x2)));
            let minY = Math.min(...lines.map(l => Math.min(l.y1, l.y2)));
            let maxY = Math.max(...lines.map(l => Math.max(l.y1, l.y2)));

            // Initialize or update global bounds
            if (window.canvasState.scale === null) {
                window.canvasState.minX = minX;
                window.canvasState.maxX = maxX;
                window.canvasState.minY = minY;
                window.canvasState.maxY = maxY;
            } else {
                window.canvasState.minX = Math.min(window.canvasState.minX, minX);
                window.canvasState.maxX = Math.max(window.canvasState.maxX, maxX);
                window.canvasState.minY = Math.min(window.canvasState.minY, minY);
                window.canvasState.maxY = Math.max(window.canvasState.maxY, maxY);
            }

            // Calculate scale with padding
            const padding = window.canvasState.padding;
            const rangeX = window.canvasState.maxX - window.canvasState.minX;
            const rangeY = window.canvasState.maxY - window.canvasState.minY;

            // Handle case where all lines are at the same point
            let scale = 1;
            if (rangeX > 0 && rangeY > 0) {
                const scaleX = (canvas.width - 2 * padding) / rangeX;
                const scaleY = (canvas.height - 2 * padding) / rangeY;
                scale = Math.min(scaleX, scaleY);
            }

            window.canvasState.scale = scale;
            console.log('scale:', scale);

            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;

            lines.forEach(line => {
                const x1 = (line.x1 - window.canvasState.minX) * window.canvasState.scale + padding;
                const y1 = (line.y1 - window.canvasState.minY) * window.canvasState.scale + padding;
                const x2 = (line.x2 - window.canvasState.minX) * window.canvasState.scale + padding;
                const y2 = (line.y2 - window.canvasState.minY) * window.canvasState.scale + padding;

                // Draw the line
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            });

            console.log('Lines drawn:', lines.length);
        };

        window.clear = function() {
            console.log('Clearing canvas...');
            const canvas = document.getElementById('lineCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            window.canvasState.scale = null
        }


        window.drawRect = function(rect, clearCanvas = false) {
            console.log('Drawing rect...');
            const canvas = document.getElementById('lineCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            if (clearCanvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                window.resetCanvasScale();
            }

            // Update global bounds if needed
            if (window.canvasState.scale === null) {
                window.canvasState.minX = rect.minX;
                window.canvasState.maxX = rect.maxX;
                window.canvasState.minY = rect.minY;
                window.canvasState.maxY = rect.maxY;

                const padding = window.canvasState.padding;
                const rangeX = rect.maxX - rect.minX;
                const rangeY = rect.maxY - rect.minY;

                let scale = 1;
                if (rangeX > 0 && rangeY > 0) {
                    const scaleX = (canvas.width - 2 * padding) / rangeX;
                    const scaleY = (canvas.height - 2 * padding) / rangeY;
                    scale = Math.min(scaleX, scaleY) ;
                }
                window.canvasState.scale = scale;
            } else {
                window.canvasState.minX = Math.min(window.canvasState.minX, rect.minX);
                window.canvasState.maxX = Math.max(window.canvasState.maxX, rect.maxX);
                window.canvasState.minY = Math.min(window.canvasState.minY, rect.minY);
                window.canvasState.maxY = Math.max(window.canvasState.maxY, rect.maxY);
            }

            const padding = window.canvasState.padding;
            ctx.fillStyle = '#ff00ff';
            ctx.lineWidth = 2;

            const x = (rect.minX - window.canvasState.minX) * window.canvasState.scale + padding;
            const y = (rect.minY - window.canvasState.minY) * window.canvasState.scale + padding;
            const width = (rect.maxX - rect.minX) * window.canvasState.scale;
            const height = (rect.maxY - rect.minY) * window.canvasState.scale;

            ctx.fillRect(x, y, width, height);

            console.log('Rect drawn');
        };

        window.drawRects = function(rects, color, clearCanvas = false) {
            console.log('Drawing rects...', rects.length);
            const canvas = document.getElementById('lineCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            if (clearCanvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                window.resetCanvasScale();
            }

            // Calculate bounds for all rects
            let minX = Math.min(...rects.map(r => r.minX));
            let maxX = Math.max(...rects.map(r => r.maxX));
            let minY = Math.min(...rects.map(r => r.minY));
            let maxY = Math.max(...rects.map(r => r.maxY));

            // Initialize or update global bounds
            if (window.canvasState.scale === null) {
                window.canvasState.minX = minX;
                window.canvasState.maxX = maxX;
                window.canvasState.minY = minY;
                window.canvasState.maxY = maxY;

                const padding = window.canvasState.padding;
                const rangeX = maxX - minX;
                const rangeY = maxY - minY;

                let scale = 1;
                if (rangeX > 0 && rangeY > 0) {
                    const scaleX = (canvas.width - 2 * padding) / rangeX;
                    const scaleY = (canvas.height - 2 * padding) / rangeY;
                    scale = Math.min(scaleX, scaleY); // 90% smaller
                }
                window.canvasState.scale = scale;
            } else {
                window.canvasState.minX = Math.min(window.canvasState.minX, minX);
                window.canvasState.maxX = Math.max(window.canvasState.maxX, maxX);
                window.canvasState.minY = Math.min(window.canvasState.minY, minY);
                window.canvasState.maxY = Math.max(window.canvasState.maxY, maxY);
            }

            const padding = window.canvasState.padding;
            console.log('scale:', window.canvasState.scale);

            ctx.strokeStyle = '#000000';
            ctx.fillStyle = color;
            ctx.lineWidth = 1;

            rects.forEach(rect => {
                const x = (rect.minX - window.canvasState.minX) * window.canvasState.scale + padding;
                const y = (rect.minY - window.canvasState.minY) * window.canvasState.scale + padding;
                const width = (rect.maxX - rect.minX) * window.canvasState.scale;
                const height = (rect.maxY - rect.minY) * window.canvasState.scale;

                ctx.fillRect(x, y, width, height);
                ctx.strokeRect(x, y, width, height);
            });

            console.log('Rects drawn:', rects.length);
        };


    </script>
    </body>

</html>
