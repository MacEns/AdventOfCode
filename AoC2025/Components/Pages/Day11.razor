@page "/day11"

<PageTitle>Day 11</PageTitle>

<InputDisplay InputFileLoader="InputFileLoader" Day="11" @ref="InputDisplay" />

<div class="d-flex flex-row gap-2 mb-2">
    <button class="btn btn-primary" @onclick="SolvePart1">Solve Part 1</button>
    <button class="btn btn-primary" @onclick="SolvePart2">Solve Part 2</button>
    <button class="btn btn-primary" @onclick="Test">Test</button>
    <button class="btn btn-primary" @onclick="Test2">Test2</button>

    <p>Part 1: @Part1Result</p>
    <p>Part 2: @Part2Result</p>
</div>

@if (Devices.Any())
{
    <div class="mb-4 overflow-auto" style="width: 1000px;">
        <table class="table table-sm table-bordered">
            <tbody>
            @foreach (var (y, device) in Devices.Index())
            {
                <tr class="@(device.Value.IsDac ? "table-warning" : device.Value.IsFft ? "table-info" : "")">
                    <td>@(y)</td>
                    <td>@device.Key</td>
                    <td>@device.Value.OutputString</td>
                </tr>
            }
            </tbody>
        </table>
    </div>
}

@code {
    [CascadingParameter]
    public Services.InputFileLoader InputFileLoader { get; set; } = default!;

    private List<string> InputLines { get; set; } = new();
    private Dictionary<string, Device> Devices { get; set; } = new();

    private InputDisplay InputDisplay { get; set; } = default!;

    private long Part1Result { get; set; } = 0;
    private long Part2Result { get; set; } = 0;

    private List<string> TestData = new()
    {
        "aaa: you hhh",
        "you: bbb ccc",
        "bbb: ddd eee",
        "ccc: ddd eee fff",
        "ddd: ggg",
        "eee: out",
        "fff: out",
        "ggg: out",
        "hhh: ccc fff iii",
        "iii: out",
    };

    private List<string> TestData2 = new()
    {
        "svr: aaa bbb",
        "aaa: fft",
        "fft: ccc",
        "bbb: tty",
        "tty: ccc",
        "ccc: ddd eee",
        "ddd: hub",
        "hub: fff",
        "eee: dac",
        "dac: fff",
        "fff: ggg hhh",
        "ggg: out",
        "hhh: out",
    };

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            InputLines = InputDisplay.GetInputLines();
            StateHasChanged();
        }

        return base.OnAfterRenderAsync(firstRender);
    }

    private void SolvePart1()
    {
        Devices = InputLines.Select(x => new Device(x)).ToDictionary(x => x.Name);
        var device = Devices["you"];

        Part1Result = GetOutCount(device);
    }

    private void Test()
    {
        Devices = TestData.Select(x => new Device(x)).ToDictionary(x => x.Name);

        var result = 0;
        var device = Devices["you"];

        result = GetOutCount(device);

        Console.WriteLine($"Result: {result}");
    }

    private int GetOutCount(Device device)
    {
        if (device.IsOut)
        {
            return 1;
        }

        var devices = Devices.Where(d => device.Outputs.Contains(d.Key)).ToList();
        return devices.Select(x => GetOutCount(x.Value)).Sum();
    }

    private async Task SolvePart2()
    {
        Devices = InputLines
            .Select(x => new Device(x))
            .OrderBy(x => x.Name != "svr")
            .ThenBy(x => !x.IsDac)
            .ThenBy(x => !x.IsFft)
            .ThenBy(x => !x.IsOut)
            .ToDictionary(x => x.Name);

        var devices = Devices.ToDictionary(x => x.Key, x => x.Value.Outputs);
        var device = devices["svr"];

        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);


        Console.WriteLine($"Finding paths...");
        var paths = FindPaths(["svr"], devices);
        Part2Result = paths.Count;
    }

    private List<List<string>> FindPaths(List<string> path, Dictionary<string, List<string>> devices)
    {
        var device = path.Last();
        if (devices[device].Contains("out") && path.Contains("dac") && path.Contains("fft"))
        {
            Console.WriteLine("  ****   " + PrintPath(path));
            return [path];
        }
        else if (devices[device].Contains("out"))
        {
            if (path.Contains("dac") && path.Contains("fft"))
            {
                Console.WriteLine(PrintPath(path));
            }

            return [];
        }


        var nextDevices = devices[device].ToList();

        List<List<string>> paths = [];
        foreach (var d in nextDevices)
        {
            var nextPaths = FindPaths(path.Append(d).ToList(), devices);
            foreach (var p in nextPaths)
            {
                if (!paths.All(x => ContainsSequence(x, p.TakeLast(3))))
                {
                    paths.Add(p);
                }
            }
        }

        return paths
            .DistinctBy(x => string.Join(",",x))
            .Where(x => x.Any())
            .ToList();
    }

    public bool ContainsSequence(IEnumerable<string> source, IEnumerable<string> sequence)
    {
        if (source == null || sequence == null) return false;
        var sourceList = source.ToList();
        var sequenceList = sequence.ToList();

        if (sequenceList.Count == 0) return true; // An empty sequence is always found
        if (sourceList.Count < sequenceList.Count) return false;

        // Iterate through all possible starting indices in the source list
        return Enumerable.Range(0, sourceList.Count - sequenceList.Count + 1)
            .Any(startIndex => sourceList.Skip(startIndex).Take(sequenceList.Count).SequenceEqual(sequenceList));
    }

    private async Task Test2()
    {
        Devices = InputLines.Select(x => new Device(x)).ToDictionary(x => x.Name);
        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);

        var nodes = InputLines
            .Select(x => new Node(x))
            .Append(new Node("out:"))
            .ToDictionary(x => x.Name);
        foreach (var node in nodes.Values)
        {
            node.Children = node.OutputStrings
                .Select(x => nodes.TryGetValue(x, out var y) ? y : null)
                .Where(x => x != null)
                .ToList();
        }

        var startNode = nodes["svr"];

        Console.WriteLine($"Finding paths 'svr' to 'fft'...");
        var svrFftPaths = FindAllPaths(startNode, "fft");
        Console.WriteLine($"Found {svrFftPaths.Count} svr -> fft paths.");
        if (svrFftPaths.Any(x => x.Contains("dac")))
        {
            Console.WriteLine("svr -> fft paths contain dac");
        }


        Console.WriteLine($"Finding paths 'svr' to 'dac'...");
        var svrDacPaths = FindAllPaths(startNode, "dac");
        Console.WriteLine($"Found {svrDacPaths.Count} svr -> dac paths.");
        if (svrDacPaths.Any(x => x.Contains("fft")))
        {
            Console.WriteLine("svr -> dac paths contain fft");
        }


    }

    // The main function to initiate the path finding
    private List<List<string>> FindAllPaths(Node root, string endNodeName = "out")
    {
        List<List<string>> paths = new List<List<string>>();
        if (root == null)
        {
            return paths;
        }

        List<string> currentPath = new List<string>();
        // Call the recursive helper function
        CollectPathsRecursive(root, currentPath, paths, endNodeName);
        return paths;
    }

    // A recursive helper function to perform DFS
    private void CollectPathsRecursive(Node node, List<string> currentPath, List<List<string>> allPaths, string endNodeName)
    {
        // Add the current node's data to the path
        currentPath.Add(node.Name);

        // Check if we've reached the end node
        if (node.Name == endNodeName)
        {
            // Check if path contains both dac and fft before adding
            if (currentPath.Contains("dac") && currentPath.Contains("fft"))
            {
                Console.WriteLine(PrintPath(currentPath));
                allPaths.Add(new List<string>(currentPath)); // Add a copy of the path
            }
            // Backtrack and return
            currentPath.RemoveAt(currentPath.Count - 1);
            return;
        }

        // If it's a leaf node (no children), add the current path to the results
        if (node.Children.Count == 0)
        {
            allPaths.Add(new List<string>(currentPath)); // Add a copy of the path
        }
        else
        {
            // Otherwise, recurse for all children
            foreach (var child in node.Children)
            {
                if (child.Name == endNodeName)
                {
                    // Check if path contains both dac and fft
                    if (currentPath.Contains("dac") && currentPath.Contains("fft"))
                    {
                        var pathWithEnd = new List<string>(currentPath) { endNodeName };
                        Console.WriteLine(PrintPath(pathWithEnd));
                        allPaths.Add(pathWithEnd);
                    }
                }

                CollectPathsRecursive(child, currentPath, allPaths, endNodeName);
            }
        }

        // Backtrack: remove the current node's data as we move back up the tree
        currentPath.RemoveAt(currentPath.Count - 1);
    }



    private List<List<Device>> GetOutPaths(List<Device> path)
    {
        var device = path.Last();
        if (device.IsOut)
        {
            return [path];
        }

        // Console.WriteLine(PrintPath(path));

        var devices = Devices
            .Where(d => device.Outputs.Contains(d.Key))
            .ToList();

        return devices
            .SelectMany(x => GetOutPaths(path.Append(x.Value).ToList()))
            .ToList();
    }

    private List<List<Device>> GetPaths(List<Device> path)
    {
        var device = path.Last();
        if (device.IsOut && path.Any(x => x.IsDac) && path.Any(x => x.IsFft))
        {
            return [path];
        }
        else if (device.IsOut)
        {
            return [];
        }

        // Console.WriteLine(PrintPath(path));

        var devices = Devices
            .Where(d => device.Outputs.Contains(d.Key))
            .ToList();

        List<List<Device>> paths = [];
        foreach (var d in devices)
        {
            paths.AddRange(GetPaths(path.Append(d.Value).ToList()));
        }

        return paths;
    }

    private string PrintPath(List<Device> path) => string.Join(" -> ", path.Select(x => x.Name));
    private string PrintPath(List<string> path) => string.Join(" -> ", path);
    private string PrintPath(Stack<Node> path) => string.Join(" -> ", path.Select(x => x.Name));

    private class Device
    {
        public Device(string row)
        {
            var chunks = row.Split(':');
            Name = chunks[0].Trim();
            Outputs = chunks[1].Trim().Split(' ').Select(o => o.Trim()).ToList();
        }

        public string Name { get; set; }
        public List<string> Outputs { get; set; } = [];

        public string OutputString => string.Join(", ", Outputs);

        public bool IsOut => OutputString == "out";
        public bool IsDac => Name == "dac";
        public bool IsFft => Name == "fft";
    }

    private class Node
    {
        public string Name { get; set; } = "";
        public List<string> OutputStrings { get; set; } = [];
        public List<Node> Children { get; set; } = [];

        public Node(string row)
        {
            var chunks = row.Split(':');
            Name = chunks[0].Trim();
            OutputStrings = chunks[1].Trim().Split(' ').Select(o => o.Trim()).ToList();
        }

    }
}

