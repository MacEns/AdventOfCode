@page "/day8"

<PageTitle>Day 8</PageTitle>

<InputDisplay InputFileLoader="InputFileLoader" Day="8" @ref="InputDisplay" />

<div class="d-flex flex-row gap-2 mb-2">
    <button class="btn btn-primary" @onclick="SolvePart1">Solve Part 1</button>
    <button class="btn btn-primary" @onclick="SolvePart2">Solve Part 2</button>
    <button class="btn btn-primary" @onclick="Test">Test</button>
    <button class="btn btn-primary" @onclick="Test2">Test2</button>
    <button class="btn btn-primary" @onclick="TestEdges">TestEdges</button>

    @{
        var p1Class = Part1Result == 0
            ? ""
            : Part1Result == 52668
                ? "fw-bold text-success"
                : "fw-bold text-danger";
    }
    <p class="@(p1Class)">Part 1: @Part1Result</p>
    <p>Part 2: @Part2Result</p>
</div>


@if (Distances.Any())
{
    <div class="d-flex flex-row  gap-2">
        <div class="mb-4 overflow-auto" style="width: 500px;">
            <table class="table table-sm table-bordered">
                <tbody>
                @foreach (var row in TestData.Index())
                {
                    <tr>
                        <td>@(row.Index + 1)</td>
                        <td class="@(Circuits.Any(c => c.Contains(row.Item.Id)) ? "" : "table-warning")">@row.Item.Id</td>
                    </tr>
                }
                </tbody>
            </table>
        </div>

        <div class="mb-4 overflow-auto" style="width: 1200px;">
            <table class="table table-sm table-bordered">
                <tbody>
                @foreach (var (i, circuit) in Circuits.Index())
                {
                    <tr>
                        <td>@(i + 1)</td>
                        <td>@circuit.Count </td>
                        <td>@string.Join(", ", circuit)</td>
                    </tr>
                }
                </tbody>
            </table>
        </div>
    </div>
}

@code {
    [CascadingParameter]
    public Services.InputFileLoader InputFileLoader { get; set; } = default!;

    private List<string> InputLines { get; set; } = new();
    private Dictionary<string, V3> Coordinates { get; set; } = new();

    private List<(string V1, string V2)> Connections { get; set; } = new();

    private InputDisplay InputDisplay { get; set; } = default!;

    private int Part1Result { get; set; } = 0;
    private long Part2Result { get; set; } = 0;

    private List<V3> TestData = new()
    {
        new V3("162,817,812"),
        new V3("57,618,57"),
        new V3("906,360,560"),
        new V3("592,479,940"),
        new V3("352,342,300"),
        new V3("466,668,158"),
        new V3("542,29,236"),
        new V3("431,825,988"),
        new V3("739,650,466"),
        new V3("52,470,668"),
        new V3("216,146,977"),
        new V3("819,987,18"),
        new V3("117,168,530"),
        new V3("805,96,715"),
        new V3("346,949,466"),
        new V3("970,615,88"),
        new V3("941,993,340"),
        new V3("862,61,35"),
        new V3("984,92,344"),
        new V3("425,690,689"),
    };

    Dictionary<string, List<KeyValuePair<string, double>>> Distances = new();

    private List<HashSet<string>> Circuits { get; set; } = new();

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            InputLines = InputDisplay.GetInputLines();
            Coordinates = InputLines.Select(x => new V3(x)).ToDictionary(x => x.Id);
            StateHasChanged();
        }

        return base.OnAfterRenderAsync(firstRender);
    }

    private async Task Test() => await Connect(TestData, 10);
    private async Task Test2() => await Connect2(TestData, 10);

    private async Task Connect(List<V3> data, int iterations)
    {
        var startTime = DateTime.Now;

        Distances = new();
        Circuits = new();

        Distances = GetDistances(data);

        var edges = GetEdges2(Distances);

        // Create initial circuits from closest edges
        Circuits = data.Select(x => new HashSet<string> { x.Id }).ToList();

        Console.WriteLine("Connecting edges...");
        var connectionCount = 0;
        while (edges.Any() && connectionCount < iterations)
        {
            if (edges.Count % 1000 == 0)
            {
                Console.WriteLine($"Edges Remaining: {edges.Count}");
            }

            var min = edges.First();

            if (Circuits.Any(x => x.Contains(min.V1.Id) && x.Contains(min.V2.Id)))
            {
                edges.Remove(min);
                connectionCount++;
                continue;
            }

            edges.Remove(min);

            var v1Circuit = Circuits.FirstOrDefault(x => x.Contains(min.V1.Id));
            var v2Circuit = Circuits.FirstOrDefault(x => x.Contains(min.V2.Id));

            v1Circuit.UnionWith(v2Circuit);
            Circuits.Remove(v2Circuit);

            connectionCount++;
        }

        Console.WriteLine($"Edges.Count {edges.Count} | data.Count {data.Count} | Circuits.Count {Circuits.Count}");

        Console.WriteLine($"Program ran in {(DateTime.Now - startTime).TotalSeconds.ToString("F2")} seconds");
    }

    private async Task<long> Connect2(List<V3> data, int iterations)
    {
        var startTime = DateTime.Now;

        Distances = GetDistances(data);
        var edges = GetEdges2(Distances);
        Circuits = data.Select(x => new HashSet<string> { x.Id }).ToList();

        Console.WriteLine("Connecting edges...");
        var connectionCount = 0;
        var finalEdge = edges.First();
        while (edges.Any() && connectionCount < iterations && Circuits.Count > 1)
        {
            if (edges.Count % 1000 == 0)
            {
                Console.WriteLine($"Edges: {edges.Count}");
            }

            if (Circuits.Count % 10 == 0)
            {
                Console.WriteLine($"Circuits: {Circuits.Count}");
            }

            var min = edges.First();

            if (Circuits.Any(x => x.Contains(min.V1.Id) && x.Contains(min.V2.Id)))
            {
                edges.Remove(min);
                connectionCount++;
                finalEdge = min;
                continue;
            }

            edges.Remove(min);
            finalEdge = min;

            var v1Circuit = Circuits.FirstOrDefault(x => x.Contains(min.V1.Id));
            var v2Circuit = Circuits.FirstOrDefault(x => x.Contains(min.V2.Id));

            v1Circuit.UnionWith(v2Circuit);
            Circuits.Remove(v2Circuit);

            connectionCount++;
        }

        Console.WriteLine(finalEdge.Id);


        Console.WriteLine($"Edges.Count {edges.Count} | data.Count {data.Count} | Circuits.Count {Circuits.Count}");

        Console.WriteLine($"Program ran in {(DateTime.Now - startTime).TotalSeconds.ToString("F2")} seconds");

        return (long)finalEdge.V1.X * (long)finalEdge.V2.X;
    }

    private Dictionary<string, List<KeyValuePair<string, double>>> GetDistances(List<V3> data)
    {
        Console.Write("Generating Distances...");
        var startTime = DateTime.Now;
        Dictionary<string, List<KeyValuePair<string, double>>> distances = new();
        foreach (var v1 in data)
        {
            List<KeyValuePair<string, double>> v1Distances = new();
            foreach (var v2 in data)
            {
                if (v1 == v2)
                {
                    continue;
                }

                var dist = v1.Distance(v2);
                v1Distances.Add(new(v2.Id, dist));
            }

            v1Distances = v1Distances.OrderBy(x => x.Value).ToList();
            distances.Add(v1.Id, v1Distances);
        }

        Console.WriteLine($"  Done in {(DateTime.Now - startTime).TotalSeconds:F4} seconds");
        return distances;
    }

    private void TestEdges()
    {
        Console.WriteLine();
        var distances = GetDistances(Coordinates.Values.ToList());
        var edges = GetEdges(distances);
        var edges2 = GetEdges2(distances);
        Console.WriteLine();
    }

    private List<Edge> GetEdges(Dictionary<string, List<KeyValuePair<string, double>>> distances)
    {
        Console.Write("Generating Edges...");
        var startTime = DateTime.Now;

        var edges = distances
           .SelectMany(x =>
           {
               return x.Value.Select(y => new Edge(x.Key, y.Key));
           })
           .OrderBy(x => x.Distance)
           .DistinctBy(x => x.Id)
           .ToList();

        Console.WriteLine($"  Done in {(DateTime.Now - startTime).TotalSeconds:F4} seconds");
        return edges;
    }

    private List<Edge> GetEdges2(Dictionary<string, List<KeyValuePair<string, double>>> distances)
    {
        Console.Write("Generating Edges2...");
        var startTime = DateTime.Now;
        List<Edge> edges = [];

        for (var i = 0; i < distances.Count; i++)
        {
            var cur = distances.ElementAt(i);
            edges.AddRange(from n in cur.Value where cur.Key != n.Key select new Edge(cur.Key, n.Key));
        }

        Console.WriteLine($"  Done in {(DateTime.Now - startTime).TotalSeconds:F4} seconds");

        return edges
            .DistinctBy(x => x.Id)
            .OrderBy(x => x.Distance)
            .ToList();
    }

    private async Task SolvePart1()
    {
        await Connect(Coordinates.Values.ToList(), 1000);
        var top3 = Circuits.Select(x => x.Count).OrderDescending().Take(3).ToList();
        Part1Result = top3[0] * top3[1] * top3[2];
    }

    private async Task SolvePart2()
    {
        Part2Result = await Connect2(Coordinates.Values.ToList(), int.MaxValue);
    }

    private class V3
    {
        public V3(string s)
        {
            var parts = s.Split(',', StringSplitOptions.TrimEntries);
            X = long.Parse(parts[0]);
            Y = long.Parse(parts[1]);
            Z = long.Parse(parts[2]);
        }

        public long X { get; set; } = 0;
        public long Y { get; set; } = 0;
        public long Z { get; set; } = 0;

        public string Id => $"({X},{Y},{Z})";

        public bool Equals(V3 other)
        {
            return Id == other.Id;
        }

        public double Distance(V3 v3) => Math.Sqrt(Math.Pow(v3.X - X, 2) + Math.Pow(v3.Y - Y, 2) + Math.Pow(v3.Z - Z, 2));
    }

    private class Edge
    {
        public Edge(V3 v1, V3 v2)
        {
            V1 = v1;
            V2 = v2;
        }

        public Edge(string a, string b)
        {
            V1 = new V3(a.TrimStart('(').TrimEnd(')'));
            V2 = new V3(b.TrimStart('(').TrimEnd(')'));
        }

        public V3 V1 { get; set; }
        public V3 V2 { get; set; }
        public double Distance => V1.Distance(V2);

        public string Id
        {
            get
            {
                var origin = new V3("0, 0, 0");
                var max = V1.Distance(origin) >= V2.Distance(origin) ? V1.Id : V2.Id;
                var min = max == V1.Id ? V2.Id : V1.Id;
                return $"{max}|{min}";
            }
        }

        public bool Equals(Edge other)
        {
            return (V1.Equals(other.V1) && V2.Equals(other.V2)) || (V1.Equals(other.V2) && V2.Equals(other.V1));
        }
    }
}

