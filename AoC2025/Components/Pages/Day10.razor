@page "/day10"

<PageTitle>Day 10</PageTitle>

<InputDisplay InputFileLoader="InputFileLoader" Day="10" @ref="InputDisplay" />

<div class="d-flex flex-row gap-2 mb-2">
    <button class="btn btn-primary" @onclick="SolvePart1">Solve Part 1</button>
    <button class="btn btn-primary" @onclick="SolvePart2">Solve Part 2</button>
    <button class="btn btn-primary" @onclick="Test">Test</button>
    <button class="btn btn-primary" @onclick="Test2">Test2</button>

    <div class="input-group border border-primary rounded-2" style="width: 200px;">
        <div class="form-control">
            <input class="form-check-input" type="checkbox" @bind="CancelTest" />
        </div>
        <label class="input-group-text">Cancel test</label>
    </div>

    <p>Part 1: @Part1Result</p>
    <p>Part 2: @Part2Result</p>
</div>

@if (Machines.Any())
{
    <div class="mb-4 overflow-auto" style="width: 1000px;">
        <table class="table table-sm table-bordered">
            <thead>
            <tr>
                <th></th>
                <th>Indicator Light Diagram</th>
                @* <th>Button Wirings</th> *@
                <th>Buttons</th>
                <th>Joltages</th>
            </tr>
            </thead>
            <tbody>
            @foreach (var (y, machine) in Machines.Index())
            {
                <tr>
                    <td>@(y)</td>
                    <td>@LightsToString(machine.IndicatorLightDiagram)</td>
                    @* <td>@ButtonWiringToString(machine.ButtonWirings)</td> *@
                    <td>(@(string.Join("), (", machine.ButtonWirings.Select(x => LightsToString(ButtonToBools(x, machine.IndicatorLights.Count))))))</td>
                    <td>@JoltagesToString(machine.Joltages)</td>
                </tr>
            }
            </tbody>
        </table>
    </div>
}
@code {
    [CascadingParameter]
    public Services.InputFileLoader InputFileLoader { get; set; } = default!;

    private List<string> InputLines { get; set; } = new();

    private List<Machine> Machines { get; set; } = new();

    private InputDisplay InputDisplay { get; set; } = default!;

    private long Part1Result { get; set; } = 0;
    private long Part2Result { get; set; } = 0;

    private bool CancelTest { get; set; } = false;

    public List<string> TestData = new()
    {
        // "[.#.] (0) (2) (1,2) {1,2,3}",
        "[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}",
        "[...#.] (0,2,3,4) (2,3) (0,4) (0,1,2) (1,2,3,4) {7,5,12,7,2}",
        "[.###.#] (0,1,2,3,4) (0,3,4) (0,1,2,4,5) (1,2) {10,11,11,5,10,5}",
    };

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            InputLines = InputDisplay.GetInputLines();
            StateHasChanged();
        }

        return base.OnAfterRenderAsync(firstRender);
    }

    private async Task Test()
    {
        Machines = TestData.Select(x => new Machine(x)).ToList();

        // Machine[0] = 2: ((0,2) and (0,1))
        // Machine[1] = 3: ((0,4), (0,1,2), and (1,2,3,4))
        // Machine[2] = 2: (0,3,4) and (0,1,2,4,5)
        // Total = 7

        // var result = SolveMachine(Machines[2]);

        var result = Machines.Select(SolveMachineLights).Sum();
        var result2 = Machines.Select(x => GetButtonsForLights(x.IndicatorLightDiagram, x.Buttons)).Sum(x => x.Count);
        Console.WriteLine($"\nTotal Result: {result}");
        Console.WriteLine($"\nTotal Result2: {result2}");
    }

    private int SolveMachineLights(Machine machine)
    {
        Console.WriteLine($"\nDiagram: ({LightsToString(machine.IndicatorLightDiagram)})");
        var result = 1;

        var diagram = machine.IndicatorLightDiagram;
        var buttons = machine.ButtonWirings.Select(x => ButtonToBools(x, diagram.Count)).ToList();

        if (buttons.Any(x => x.SequenceEqual(machine.IndicatorLightDiagram)))
        {
            Console.WriteLine($"Machine has matching perfect Button: {LightsToString(diagram)}");
            return result;
        }

        // Console.WriteLine($"No single buttons worked: ({string.Join("), (", buttons.Select(LightsToString))})");

        // Console.WriteLine("Checking button combinations...");
        var comboFound = false;
        List<List<bool>> combos = buttons.ToList();
        var maxIterations = 10;
        while (!comboFound && !CancelTest && result < maxIterations)
        {
            Console.WriteLine($"Checking {result + 1} button combinations...");
            List<List<bool>> newCombos = [];
            for (int i = 0; i < buttons.Count; i++)
            {
                if (comboFound)
                {
                    break;
                }

                for (var j = 0; j < combos.Count; j++)
                {
                    var combo = ButtonCombo(combos[j], buttons[i]);
                    // Console.WriteLine($"Checking combo ({i}) {LightsToString(buttons[i])} + {LightsToString(combos[j])} = {LightsToString(combo)} | {LightsToString(diagram)}");

                    if (LightsToString(combo).Equals(LightsToString(diagram)))
                    {
                        Console.WriteLine($"Machine has matching button Combo: {LightsToString(buttons[i])} + {LightsToString(combos[j])} = {LightsToString(diagram)}");
                        comboFound = true;
                        break;
                    }

                    newCombos.Add(combo);
                }
            }

            combos = newCombos.DistinctBy(LightsToString).ToList();
            result++;
        }

        if (comboFound)
        {
            Console.WriteLine($"Found combination with {result} buttons.");
        }

        CancelTest = false;
        return result;
    }

    private List<List<int>> GetButtonsForLights(List<bool> diagram, Dictionary<int, Button> buttons)
    {
        List<List<int>> result = [];
        Queue<List<int>> q = new();
        foreach (var button in buttons)
        {
            q.Enqueue([button.Key]);
        }

        while (q.Any() && q.Count < 50000)
        {
            var currentCombo = q.Dequeue();
            var comboResult = ExecuteCombo(currentCombo, buttons);
            if (comboResult.SequenceEqual(diagram))
            {
                result.Add(currentCombo);
            }
            else
            {
                foreach (var button in buttons)
                {
                    var newCombo = new List<int>(currentCombo) { button.Key };
                    if (newCombo.GroupBy(x => x).Select(x => x.Count()).Any(x => x >= 2))
                    {
                        continue;
                    }

                    q.Enqueue(newCombo);
                }
            }
        }

        return result
            .Select(x => x.Order().ToList())
            .DistinctBy(x => string.Join(",",x))
            .ToList();
    }

    private List<bool> ExecuteCombo(List<int> indices, Dictionary<int, Button> buttons)
    {
        var result = buttons[indices[0]].Bools;
        for (var i = 1; i < indices.Count; i++)
        {
            var prev = result;
            var next = buttons[indices[i]].Bools;
            result = ButtonCombo(result, next);
            // Console.WriteLine($"{LightsToString(prev)} + {LightsToString(next)} =>  {LightsToString(result)}");
        }

        return result;
    }

    private List<bool> ButtonCombo(List<bool> b1, List<bool> b2) => b1.Select((x, i) => (!x || !b2[i]) && (x || b2[i])).ToList();

    private void SolvePart1()
    {
        Machines = InputLines.Select(x => new Machine(x)).ToList();
        Console.WriteLine($"Longest light sequence: {Machines.Max(x => x.IndicatorLightDiagram.Count)}");

        Part1Result = Machines.Select(SolveMachineLights).Sum();
    }

    private void Test2()
    {
        // Machine[0] = 10: (3) once, (1,3) three times, (2,3) three times, (0,2) once, and (0,1) twice.
        // Machine[1] = 12: (0,2,3,4) twice, (2,3) five times, and (0,1,2) five times.
        // Machine[2] = 11: (0,1,2,3,4) five times, (0,1,2,4,5) five times, and (1,2) once.
        // Total = 33

        Machines = TestData.Select(x => new Machine(x)).ToList();

        var total = 0;
        foreach (var (i, m) in Machines.Index())
        {
            var result = SolveMachineJoltage(m);
            Console.WriteLine($"{i}: {result}");
            total += result;
        }

        Console.WriteLine($"Solution {total}");
    }

    private void SolvePart2()
    {
        Machines = InputLines.Select(x => new Machine(x)).Where(x => x != null).ToList();
        Part2Result = 0;

        foreach (var (i, m) in Machines.Index())
        {
            var result = SolveMachineJoltage(m);
            Console.WriteLine($"{i}: {result}");
            Part2Result += result;
        }

    }

    private int SolveMachineJoltage(Machine machine)
    {
        var buttons = machine.Buttons;
        var joltages = machine.Joltages;
        var joltageLights = joltages.Select(x => x % 2 == 1).ToList();
        // Console.WriteLine($"Joltage Light Setting: ({LightsToString(joltageLights)})");

        var buttonCombos = GetButtonsForLights(joltageLights, buttons);
        // Console.WriteLine($"Combo for Lights: ({buttonCombos.Count})");
        // foreach (var combo in buttonCombos)
        // {
        //     Console.WriteLine($"   => {string.Join(", ", combo.Select(x => buttons[x]))}");
        // }

        var results = GetButtonsForJoltage(joltages, buttons, buttonCombos);
        return results.Any() ? results.Min(x => x.Count) : -1;
    }

    private List<List<int>> GetButtonsForJoltage(List<int> target, Dictionary<int, Button> buttons, List<List<int>> combos)
    {
        List<List<int>> result = [];

        foreach (var combo in combos)
        {
            var comboJolts = GetJoltages(buttons, combo, target.Count);
            var remainingJolts = target.Select((x, i) => x - comboJolts[i]).ToList();

            var doubles = buttons.Select(x => new List<int> { x.Key, x.Key }).ToList();


            Queue<List<int>> q = new();
            foreach (var button in doubles)
            {
                q.Enqueue(button);
            }

            while (q.Any() && q.Count < 500000)
            {
                var currentCombo = q.Dequeue();
                var comboJoltsResult = GetJoltages(buttons, currentCombo, target.Count);
                if (comboJoltsResult.SequenceEqual(remainingJolts))
                {
                    result.Add(combo.Concat(currentCombo).ToList());
                }
                else
                {
                    foreach (var doubleButton in doubles)
                    {
                        var newCombo = currentCombo.Concat(doubleButton).ToList();
                        if (JoltageExceeded(GetJoltages(buttons, newCombo, target.Count), remainingJolts))
                        {
                            continue;
                        }

                        q.Enqueue(newCombo);
                    }
                }
            }
        }


        return result
            .DistinctBy(x => string.Join(",", x.Order()))
            .ToList();
    }

    private List<int> GetJoltages(Dictionary<int, Button> buttons, List<int> pressCount, int joltageCount)
    {
        var result = Enumerable.Range(0, joltageCount).Select(_ => 0).ToList();
        foreach (var p in pressCount)
        {
            var buttonPressed = buttons[p];
            for (var i = 0; i < buttonPressed.Bools.Count; i++)
            {
                if (buttonPressed.Bools[i])
                {
                    result[i]++;
                }
            }
        }

        return result;
    }

    private bool JoltageExceeded(List<int> joltage, List<int> target) => joltage.Index().Any(x => x.Item > target[x.Index]);

    private List<bool> ButtonToBools(List<int> button, int lightCount)
    {
        var result = new List<bool>(new bool[lightCount]);
        foreach (var b in button)
        {
            result[b] = true;
        }

        return result;
    }

    private string LightsToString(List<bool> lights) => string.Concat(lights.Select(x => x ? '#' : '.'));
    private string JoltagesToString(List<int> joltages) => joltages == null ? string.Empty : string.Join(", ", joltages.Select(x => x.ToString()).ToList());

    private class Machine
    {
        public List<bool> IndicatorLights { get; set; } = new();

        public List<bool> IndicatorLightDiagram { get; set; } = new();
        public List<List<int>> ButtonWirings { get; set; } = new();
        public List<int> Joltages { get; set; } = new();

        public Dictionary<int, Button> Buttons { get; set; } = new();

        public Machine(string input)
        {
            var inputChunks = input.Split(' ');
            IndicatorLightDiagram = inputChunks[0].TrimStart('[').TrimEnd(']').Select(x => x == '#').ToList();
            IndicatorLights = IndicatorLightDiagram.Select(_ => false).ToList();

            ButtonWirings = inputChunks
                .Where(x => x.StartsWith('('))
                .Select(x => x.TrimStart('(').TrimEnd(')').Split(',').Select(y => int.Parse(y)).ToList())
                .ToList();

            Joltages = inputChunks
                .FirstOrDefault(x => x.StartsWith('{'))
                .TrimStart('{')
                .TrimEnd('}')
                .Split(',')
                .Select(y => int.Parse(y))
                .ToList();

            Buttons = ButtonWirings
                .Select(x => new Button(x, IndicatorLightDiagram.Count))
                .Index()
                .ToDictionary(x => x.Index, x => x.Item);
        }
    }

    private class Button
    {
        public Button(List<int> values, int lightCount)
        {
            Default = values;
            Bools = ButtonToBools(values, lightCount);
            Ints = Bools.Select(x => x ? 1 : 0).ToList();
        }

        public List<int> Default { get; set; } = new();
        public List<bool> Bools { get; set; } = new();
        public List<int> Ints { get; set; } = new();

        public override string ToString() => "(" + string.Concat(Bools.Select(x => x ? '#' : '.')) + ")";

        private List<bool> ButtonToBools(List<int> button, int lightCount)
        {
            var result = new List<bool>(new bool[lightCount]);
            foreach (var b in button)
            {
                result[b] = true;
            }

            return result;
        }
    }
}

